#version 460
#extension GL_EXT_ray_tracing : enable

#include "raycommon.glsl"

layout(location = 0) rayPayloadEXT RayPayload rayPayload;
layout(location = 2) rayPayloadEXT Payload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1) uniform CameraData_ { CameraData data; } cam;

layout(set = 1, binding = 4, rgba32f) uniform image2D image_first_hit_color;
//layout(set = 1, binding = 5) writeonly buffer MousepickData { uint i[]; } mousepickData;
layout(set = 1, binding = 6, rgba32f) uniform image2D image_first_hit_normals;
layout(set = 1, binding = 7, rgba32f) uniform image2D image_first_hit_base_color;
layout(set = 1, binding = 8, rgba32f) uniform image2D image_second_hit_color;

// Random number generation using pcg32i_random_t, using inc = 1. Our random state is a uint.
uint stepRNG(uint rngState) {
  return rngState * 747796405 + 1;
}

vec3 filmic(vec3 x) {
  vec3 X = max(vec3(0.0), x - 0.004);
  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, vec3(2.2));
}

float filmic(float x) {
  float X = max(0.0, x - 0.004);
  float result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, 2.2);
}

// Steps the RNG and returns a floating-point value between 0 and 1 inclusive.
float stepAndOutputRNGFloat(inout uint rngState) {
  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].
  rngState  = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word      = (word >> 22) ^ word;
  return float(word) / 4294967295.0f;
}
  
void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;
	
	/*vec2 uv = d;
	vec2 fishuv;
	float fishyness = 0.5;
    fishuv.x = (1.0 - uv.y*uv.y) * fishyness * uv.x;
    fishuv.y = (1.0 - uv.x*uv.x) * fishyness * uv.y;
	d = uv - fishuv;*/
	// https://www.shadertoy.com/view/ltSXRz

	/*
	vec2 uv = fragCoord.xy / iResolution.xy;
    //uv.x *= iResolution.x/iResolution.y;
    uv = (uv - 0.5) * 2.0;
        
    vec2 fishuv;
    float fishyness = INTENSITY;
    fishuv.x = (1.0 - uv.y*uv.y) * fishyness * uv.x;
    fishuv.y = (1.0 - uv.x*uv.x) * fishyness * uv.y;
	*/


	vec4 origin = cam.data.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.data.projInverse * vec4(d.x, d.y, 1, 1) ;		

	uint rayFlags = gl_RayFlagsOpaqueEXT;// | gl_RayFlagsCullFrontFacingTrianglesEXT;
	uint cullMask = 0xff;
	float tmin = 0.001;
	float tmax = 10000.0;

	//rayPayload.distance = 0; // this stops the screen being black when you inserted that ray cast above
	
    vec3 color = vec3(0.0);
    vec3 firstBounce = vec3(0.0);
    vec3 secondBounce = vec3(0.0);
	
	
	// Initial seed
	uint seed = cam.data.frameIndex;

	const uvec2 resolution = uvec2(512, 288) * 1;
	const uvec2 pixel = uvec2(gl_LaunchIDEXT.xy);
	uint rngState = resolution.x * pixel.y + pixel.x + cam.data.frameIndex * 45678;
	

	int sampleCount = 4;
	vec3 totalColor = vec3(0);

	vec3 finalNormal = vec3(0);
	vec3 baseColor = vec3(0);

	for (int i = 0; i < sampleCount; i++) 
	{
		seed += i;

		// Initial ray settings
		rayPayload.hitType = HIT_TYPE_UNDEFINED;


		rayPayload.color = vec3(0);
		rayPayload.normal = vec3(0);
		rayPayload.nextRayOrigin = vec3(0);
		rayPayload.nextFactor = vec3(0);
		rayPayload.nextRayDirection = vec3(0);
		rayPayload.seed = seed;
		rayPayload.writeToImageStore = 1;
		rayPayload.vertexNormal = vec3(0,0,0);
		rayPayload.meshIndex = 0.0;


		vec3 vertexNormal = vec3(1, 0, 0);
		float meshIndex = 0;

		vec4 transparentAccumulation = vec4(0);
		bool hitTranslucent = false;

		vec3 newFinal = vec3(0);

		const vec2 screenUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
		vec2 d2 = screenUV * 2.0 - 1.0;	
		vec4 direction = cam.data.viewInverse*vec4(normalize(target.xyz / target.w), 0);
				
		origin = cam.data.viewInverse * vec4(0,0,0,1);
		target = cam.data.projInverse * vec4(d2.x, d2.y, 1, 1);			
						
		rayPayload.nextRayOrigin = origin.xyz;
		rayPayload.nextRayDirection = normalize(direction.xyz);;
		rayPayload.nextFactor = vec3(1.0);
		
		vec3 contribution = vec3(1.0);
					
		// First bounce
		for (int j = 0; j < 1; j++) 
		{				
			rayPayload.bounce = 0;
			traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, rayPayload.nextRayOrigin, tmin, rayPayload.nextRayDirection, tmax, 0);				
			vertexNormal = rayPayload.vertexNormal * 0.5 + 0.5;

			meshIndex = rayPayload.meshIndex;
			firstBounce = rayPayload.color;
			contribution *= rayPayload.nextFactor;	
			finalNormal = rayPayload.normal;

			// Transparency
			if (rayPayload.hitType == HIT_TYPE_TRANSULUCENT) {
				// real but broken 
				// transparentAccumulation.xyz = rayPayload.color;
				// transparentAccumulation.w = rayPayload.alpha;

				// hack
				transparentAccumulation.xyz += rayPayload.color * rayPayload.alpha;
					
				hitTranslucent = true;
				j--;
			}
			// Mirror 
			else if (rayPayload.hitType == HIT_TYPE_MIRROR || rayPayload.hitType == HIT_TYPE_GLASS) {				
				j--;
			}
		}		

		firstBounce += transparentAccumulation.xyz;
		baseColor = contribution;

		vec3 indirectRayOrigin = rayPayload.nextRayOrigin;
		vec3 indirectRayDIrection =  rayPayload.nextRayDirection;
		vec3 indirectContribution = vec3(0);

		
		// Second bounce
		{
			// importance sampling (sampled indirect diffuse direction in normal space)
			vec3 random = random_pcg3d(uvec3(gl_LaunchIDEXT.xy, i + rayPayload.seed * 6341));
			float theta = asin(sqrt(random.y));
			float phi = 2.0 * PI * random.x;  
			vec3 localDiffuseDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
			vec3 diffuseDir = getNormalSpace(finalNormal) * localDiffuseDir;
			indirectRayDIrection = diffuseDir;

			// Check if ray points INSIDE geometry, interestingly this is so rare so you just ignore it.
			//float dotTest = dot(diffuseDir, finalNormal);

			rayPayload.bounce = 1; 
			traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, indirectRayOrigin, tmin, indirectRayDIrection, tmax, 0);
				
			indirectContribution = contribution * rayPayload.color;	

			vec3 col = indirectContribution;// + firstBounce;
			newFinal = col;

			//secondBounce += mix(firstBounce, newFinal, 0.8);
			//secondBounce = indirectContribution;

			secondBounce = rayPayload.color;
		}	
		
		
			color = newFinal.xyz;
			color.xyz = mix(firstBounce, newFinal, 0.8);
		
		totalColor += color;
	}


	
	color = totalColor / sampleCount;
	secondBounce = secondBounce / sampleCount;
	//color.xyz = mix(firstBounce, color, 0.8);
	//color += firstBounce;

	// Tonemap
	color.xyz = pow(color.xyz, vec3(1.0/2.2)); 
	color.xyz = Tonemap_ACES(color.xyz);
		
	// Brightness and contrast
	float contrast = 1.25;
	float brightness = -0.08;
	color = (color) * contrast;
	color = color + vec3(brightness,brightness,brightness);
	
	// Temperature
	float temperature = 225; // mix(1000.0, 15000.0, (sin(iTime * (PI2 / 10.0)) * 0.5) + 0.5);
	float temperatureStrength = 1.75;
	color = mix(color, color * colorTemperatureToRGB(temperature), temperatureStrength); 
	
	// Filmic tonemapping
	color = mix(color, filmic(color), 0.75);

	
	
	
	// Vignette
	float uvMagSqrd = dot(d,d);
	float amount = 0.125;
    float vignette = 1.0 - uvMagSqrd * amount;
    color *= vignette;
  
	// Darken for inventory
	if (cam.data.inventoryOpen == 1) {
		color *= vec3(0.325);
	}

	color = firstBounce;
	//secondBounce = finalNormal;

	if (rayPayload.writeToImageStore == 1) 
	{

		imageStore(image_first_hit_color, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(firstBounce, 0));
		imageStore(image_first_hit_normals, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(finalNormal, 0));
		imageStore(image_first_hit_base_color, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(baseColor, 0));
		imageStore(image_second_hit_color, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(secondBounce, 0));

		// Is this inventory screen?
		if (cam.data.inventoryOpen == 2) {
		//	imageStore(image_first_hit_color, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(firstBounce, 0));
		//	imageStore(image_first_hit_normals, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(finalNormal, 0));
		//	imageStore(image_normals, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(finalNormal, 0));
		} 
		// Otherwise draw at actual x/y
		else {
		//	imageStore(image_firstBounce, ivec2(gl_LaunchIDEXT.xy), vec4(firstBounce, 0));
		//	imageStore(image_secondBounce, ivec2(gl_LaunchIDEXT.xy), vec4(secondBounce, 0));
		//	imageStore(image_normals, ivec2(gl_LaunchIDEXT.xy), vec4(finalNormal, 0));
			//imageStore(image_normals, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0));
		}
	}
//	if (rayPayload.writeToImageStore == 1)
	//	imageStore(image, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(vec3(rayPayload.writeToImageStore), 0));

}


