#version 460
#extension GL_EXT_ray_tracing : enable

#include "raycommon.glsl"

layout(location = 0) rayPayloadEXT RayPayload rayPayload;
layout(location = 2) rayPayloadEXT Payload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1) uniform CameraData_ { CameraData data; } cam;

layout(set = 1, binding = 4, rgba8) uniform image2D image;
layout(set = 1, binding = 5) writeonly buffer MousepickData { uint i[]; } mousepickData;

// Random number generation using pcg32i_random_t, using inc = 1. Our random state is a uint.
uint stepRNG(uint rngState)
{
  return rngState * 747796405 + 1;
}

// Steps the RNG and returns a floating-point value between 0 and 1 inclusive.
float stepAndOutputRNGFloat(inout uint rngState)
{
  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].
  rngState  = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word      = (word >> 22) ^ word;
  return float(word) / 4294967295.0f;
}

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;
	
	vec4 origin = cam.data.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.data.projInverse * vec4(d.x, d.y, 1, 1) ;
		
	vec4 direction = cam.data.viewInverse*vec4(normalize(target.xyz / target.w), 0);


	uint rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsCullFrontFacingTrianglesEXT;
	uint cullMask = 0xff;
	float tmin = 0.001;
	float tmax = 10000.0;


	rayPayload.distance = 0; // this stops the screen being black when you inserted that ray cast above
	
    vec3 color = vec3(0.0);
    vec3 firstBounce = vec3(0.0);

	
	float mult = 1.0f;


	
	int MAX_RECURSION = 20;
	vec3 pixelColor          = vec3(0.0);

	vec3 summedPixelColor = vec3(0.0);

	
	// Initial ray settings
	rayPayload.done = -2;
    rayPayload.color = vec3(0);
	rayPayload.distance = 0;
	rayPayload.normal = vec3(0);
	rayPayload.nextRayOrigin = vec3(0);
	rayPayload.nextFactor = vec3(0);
	rayPayload.nextRayDirection = vec3(0);
	rayPayload.random = vec3(0);
	rayPayload.writeToImageStore = 1;

	// Initial seed
	const uvec2 resolution = uvec2(512, 288);
	const uvec2 pixel = uvec2(gl_LaunchIDEXT.xy);
	uint rngState = resolution.x * pixel.y + pixel.x + cam.data.frameIndex * 45678;
	//  rngState = resolution.x * pixel.y + pixel.x;  

	// Testing random number generation
	//float f = stepAndOutputRNGFloat(rngState);	
	//color = vec3(f);


	const int NUM_SAMPLES = 1;	
	for(int i = 0; i < NUM_SAMPLES; i++) {

			const vec2 randomPixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(stepAndOutputRNGFloat(rngState) * (NUM_SAMPLES / 2.0), stepAndOutputRNGFloat(rngState) * (NUM_SAMPLES / 2.0));
			const vec2 screenUV = randomPixelCenter/vec2(gl_LaunchSizeEXT.xy);
			vec2 d2 = screenUV * 2.0 - 1.0;	
			vec4 direction = cam.data.viewInverse*vec4(normalize(target.xyz / target.w), 0);
			vec3 rayDirection = normalize(direction.xyz);
			
			const vec4 hitPos = origin + direction * rayPayload.distance;

			// lets beging
			if (rayPayload.done == 0 ) {
				origin = cam.data.viewInverse * vec4(0,0,0,1);
				target = cam.data.projInverse * vec4(d2.x, d2.y, 1, 1);			
			} 
			else if (rayPayload.done == 1) {
				origin.xyz = hitPos.xyz + (direction.xyz * vec3(0.01));
				target = cam.data.projInverse * vec4(d2.x, d2.y, 1, 1);					
			}
			
			rayPayload.nextRayOrigin = origin.xyz;
			rayPayload.nextRayDirection = rayDirection;
			rayPayload.nextFactor = vec3(1.0);
		
			vec3 contribution = vec3(1.0);

			vec3 accumulatedColor = vec3(1.0);

			// Bounces
			int bounces = 6 ;
			for (int b = 0; b < bounces; b++) {				

			rayPayload.bounce = b;
			rayPayload.random = random_pcg3d(uvec3(gl_LaunchIDEXT.x - cam.data.frameIndex + b * 123, gl_LaunchIDEXT.y + -cam.data.frameIndex + b * 651, b + cam.data.frameIndex + b * 11));


			if (length(rayPayload.nextRayDirection) > 0.1) {

				traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, rayPayload.nextRayOrigin, tmin, rayPayload.nextRayDirection, tmax, 0);
				
				// Mirror
				if (rayPayload.done == 2) {
				}

				// Glass
				if (rayPayload.done == 3) {
					color += (rayPayload.color);// *  1.1) ;	
				}

				// 1 is transparent alpha pixels who need a new bounce
				// 2 is mirror
				// 3 is refracted glass

				if (b == 0) {
					firstBounce = rayPayload.color;
						contribution *= rayPayload.nextFactor;		

									// Russian Roulette
						if (true) {
							// Randomly terminate a path with a probability inversely equal to the throughput
							float p = max(contribution.x, max(contribution.y, contribution.z));
							if (nextRand(rngState) > p) {
								break;
							}
							// Add the energy we 'lose' by randomly terminating paths
							contribution *= 1 / p;
						}

				}

					if (rayPayload.done != 1 && rayPayload.done != 2 && rayPayload.done != 3 && b > 0) {	

						color += contribution * rayPayload.color;

						//color = mix(contribution * rayPayload.color, color, 0.15);

						contribution *= rayPayload.nextFactor;		
						
						// Russian Roulette
						if (true) {
							// Randomly terminate a path with a probability inversely equal to the throughput
							float p = max(contribution.x, max(contribution.y, contribution.z));
							if (nextRand(rngState) > p) {
								break;
							}
							// Add the energy we 'lose' by randomly terminating paths
							contribution *= 1 / p;
						}


						const vec4 hitPos2 = origin + vec4(rayDirection, 0) * rayPayload.distance;						
						//rayPayload.normal = faceforward(rayPayload.normal, rayDirection.xyz, rayPayload.normal);
						origin.xyz = hitPos2.xyz - 0.0001 * sign(dot(rayDirection.xyz, rayPayload.normal)) * rayPayload.normal;
						//rayDirection = reflect(rayDirection, rayPayload.normal);
						const float theta = 6.2831853 * stepAndOutputRNGFloat(rngState);   // Random in [0, 2pi]
						const float u     = 2.0 * stepAndOutputRNGFloat(rngState) - 1.0;  // Random in [-1, 1]
						const float r     = sqrt(1.0 - u * u);
						rayDirection      = rayPayload.normal + vec3(r * cos(theta), r * sin(theta), u);
						rayDirection = normalize(rayDirection);

						if (rayPayload.done == 0) {
							accumulatedColor *= rayPayload.color;
						} 
						else if (rayPayload.done == -1) {						
							accumulatedColor *= vec3(0.0);
						}
					}
				}
				if (rayPayload.done == 1) {
					accumulatedColor = vec3(0);
					b = 99;
					i--;
				}
				
	


				// a check I saw in
				// https://www.gsn-lib.org/apps/raytracing/index.php?name=example_pathtracing
				// which is also where u even got this whole thing working from
				if (length(rayPayload.nextRayDirection) < 0.1) {
					break;
				}

			}


		
		summedPixelColor += accumulatedColor;

	}

	//color = summedPixelColor / NUM_SAMPLES;
	color = color / NUM_SAMPLES;

	color += firstBounce;

	if (cam.data.inventoryOpen == 1) {
		color *= vec3(0.125);
	}

//	color = firstBounce;
	
   color = pow(color.xyz, vec3(1.0/2.2)); 
   vec3 tonemapped = Tonemap_ACES(color.xyz);
   //color = mix(color, tonemapped, 0.5);

	// colorContrasted 
	float contrast = 1.125;
	float brightness = -0.060;
	color = (color) * contrast;
	color = color + vec3(brightness,brightness,brightness);

	float temperature = 225; // mix(1000.0, 15000.0, (sin(iTime * (PI2 / 10.0)) * 0.5) + 0.5);
	float temperatureStrength = 1.75;
	color = mix(color, color * colorTemperatureToRGB(temperature), temperatureStrength); 

	if (rayPayload.writeToImageStore == 1) {

		// Is this inventory screen?
		if (cam.data.inventoryOpen == 2) {
			imageStore(image, ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), vec4(color, 0));
		} 
		// Otherwise draw at actual x/y
		else {
			imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0));
		}
	}
}





